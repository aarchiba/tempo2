//  Copyright (C) 2006,2007,2008,2009, George Hobbs, Russell Edwards

/*
*    This file is part of TEMPO2. 
* 
*    TEMPO2 is free software: you can redistribute it and/or modify 
*    it under the terms of the GNU General Public License as published by 
*    the Free Software Foundation, either version 3 of the License, or 
*    (at your option) any later version. 
*    TEMPO2 is distributed in the hope that it will be useful, 
*    but WITHOUT ANY WARRANTY; without even the implied warranty of 
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
*    GNU General Public License for more details. 
*    You should have received a copy of the GNU General Public License 
*    along with TEMPO2.  If not, see <http://www.gnu.org/licenses/>. 
*/

/*
*    If you use TEMPO2 then please acknowledge it by citing 
*    Hobbs, Edwards & Manchester (2006) MNRAS, Vol 369, Issue 2, 
*    pp. 655-672 (bibtex: 2006MNRAS.369..655H)
*    or Edwards, Hobbs & Manchester (2006) MNRAS, VOl 372, Issue 4,
*    pp. 1549-1574 (bibtex: 2006MNRAS.372.1549E) when discussing the
*    timing model.
*/

/* Template for a tempo2 plugin */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "tempo2.h"
#include <cpgplot.h>
#include "T2toolkit.h"
#include "TKspectrum.h"
#include "TKfit.h"
#include "fftw3.h"

using namespace std;


double G_OMEGA;
void plot6(double *cholSpecX,double *cholSpecY,int nCholSpec,double *cholWspecX,
	   double *cholWspecY,int nCholWspec,double *highFreqSpecX,
	   double *highFreqSpecY,int nHighFreqSpec,int makeps);
void doPlugin(pulsar *psr,double idt,int ipw,double ifc,double iexp,int inpt,int makeps);
int obtainTimingResiduals(pulsar *psr,double *resx,double *resy,double *rese);
void fitSineFunc(double x,double *v,int nfit,pulsar *psr,int ival);
void cubicFit(double *resx,double *resy,double *rese,int nres,double *cubicVal,double *cubicErr);
void plot1(double *resx,double *resy,double *rese,int nres,double *cubicVal,double *smoothModel,double *highFreqRes,double *hfNormCovar,int *hfNormCovarNpts,double hfZerolagNormCovar);
void removeMean(double *resx,double *resy,int n);
void fileOutput3(char *fname,double *x,double *y,double *z,int n);
void fileOutput2(char *fname,double *x,double *y,int n);
void findSmoothCurve(double *resx,double *resy,double *rese,
		     int nres,double *cubicVal,double *smoothModel,double expSmooth);
void getHighFreqRes(double *resy,double *smoothModel,int nres,double *highFreqRes);
void getHighFreqCovar(double *resx,double *rese,double *highFreqRes,int nres,double *hfNormCovar,int *hfNormCovarNpts,double *hfZerolagNormCovar);
void calculateDailyCovariance(double *x,double *y,double *e,int n,double *cv,int *in,double *zl,int usew);
int calculateSpectra(double *x,double *y,double *e,int n,int useErr,int preWhite,
		     int specType,double *specX,double *specY);
void plot2(double *origSpecX,double *origSpecY,int nOrigSpec,double *smoothSpecX0,
	   double *smoothSpecY0,int nSmoothSpec0,double *smoothSpecX1,
	   double *smoothSpecY1,int nSmoothSpec1,double *smoothSpecX2,
	   double *smoothSpecY2,int nSmoothSpec2,double *highFreqSpecX,
	   double *highFreqSpecY,int nHighFreqSpec,int makeps);
void plot3(double *preWhiteSpecX,double *preWhiteSpecY,int nPreWhiteSpec,
	   int usePreWhitening,double *highFreqSpecX,double *highFreqSpecY,
	   int nHighFreqSpec,double modelAlpha,double modelFc,int modelNfit,double modelScale,int closeit,float *minx,float *maxx);
int fitSpectra(double *preWhiteSpecX,double *preWhiteSpecY,int nPreWhiteSpec,double *modelAlpha,double *modelFc,int *modelNfit,double *modelScale,double *fitVar,int aval,int ipw,double ifc,double iexp,int inpt);
void plot3a(double *resx,double *resy,int nres,double *rawCovar,int *rawCovarNpts,
	    double zerolagRawCovar,double *ampFit,double *chisqFit,int nGridFit,
	    double bestAmp,double bestLag,double bestChisq,int makeps);

void interpolate(double *resx,double *resy,double *rese,
		 int nres,double *cubicVal,double *interpX,
		 double *interpY,int *nInterp,int interpTime,double expSmooth);
void calculateCholesky(double modelAlpha,double modelFc,double modelScale,double fitVar,double **uinv,double *covFunc,
		       double *resx,double *resy,double *rese,int nres,double *highFreqRes,double *errorScaleFactor);
void getWhiteRes(double *resx,double *resy,double *rese,int nres,double **uinv,double *cholWhiteY);
void plot4(double *resx,double *resy,double *rese,int nres,double *cholWhiteY,double *whiteCovar,int *whiteCovarNpts,double zerolagWhiteCovar);
void plot5(double *preWhiteSpecX,double *preWhiteSpecY,int nPreWhiteSpec,
	   int usePreWhitening,double *highFreqSpecX,double *highFreqSpecY,int nHighFreqSpec,
	   double modelAlpha,double modelFc,int modelNfit,double modelScale,
	   double nmodelScale,double *cholSpecX,double *cholSpecY,int nCholSpec,
	   double *cholWspecX,double *cholWspecY,int nCholWspec,int makeps);
void outputMatrix(double **uinv,int nres);
void fitExponential(double *resx,int nres,double *rawCovar,int *rawCovarNpts,double *ampFit,double *chisqFit,double *bestAmp,double *bestLag,double *bestChisq,int *nGridFit);
void formCholeskyMatrix_pl(double *c,double *resx,double *resy,double *rese,int np,double **uinv);
void calculateCholeskyCovarFunc(double bestAmp,double bestLag,int nGridFit,double **uinv,double *resx,
				double *resy,double *rese,int nres,double *covarFunc);
void outputCovarianceFunction(double *covFunc,int n,double errorScaleFactor,pulsar *psr);

void help() /* Display help */
{
  /* This function should contain usage information about the plugin which should (in general) be accessed */
  /* by the user pressing 'h'                                                                              */
}

char skipstep2=0; // test to skip step 2 added by MJK 2011-07.
bool writeFiles=true;

/* The main function called from the TEMPO2 package is 'graphicalInterface' */
/* Therefore this function is required in all plugins                       */
extern "C" int graphicalInterface(int argc,char *argv[],pulsar *psr,int *npsr) 
{
  char parFile[MAX_PSR][MAX_FILELEN];
  char timFile[MAX_PSR][MAX_FILELEN];
  int i;
  double globalParameter;
  double idt=0;
  double ifc=-1;
  double iexp=0;
  int inpt=-1;
  int ipw=-1;
  int makeps=0;

  *npsr = 1;  /* For a graphical interface that only shows results for one pulsar */

  printf("Graphical Interface: spectralModel\n");
  printf("Author:              G. Hobbs, W. Coles\n");
  printf("Version:             1.1\n");
  printf("The techniques used here were developed by W. Coles\n");
  printf(" --- type 'h' for help information\n");


  /* Obtain the .par and the .tim file from the command line */
  if (argc==4) /* Only provided .tim name */
    {
      strcpy(timFile[0],argv[3]);
      strcpy(parFile[0],argv[3]);
      parFile[0][strlen(parFile[0])-3] = '\0';
      strcat(parFile[0],"par");
    }

  /* Obtain all parameters from the command line */
  for (i=2;i<argc;i++)
    {
      if (strcmp(argv[i],"-f")==0)
	{
	  strcpy(parFile[0],argv[i+1]); 
	  strcpy(timFile[0],argv[i+2]);
	}
      else if (strcmp(argv[i],"-t")==0)
	sscanf(argv[++i],"%lf",&idt);
      else if (strcmp(argv[i],"-fc")==0)
	sscanf(argv[++i],"%lf",&ifc);
      else if (strcmp(argv[i],"-exp")==0)
	sscanf(argv[++i],"%lf",&iexp);
      else if (strcmp(argv[i],"-pw")==0)
	sscanf(argv[++i],"%d",&ipw);
      else if (strcmp(argv[i],"-nfit")==0)
	sscanf(argv[++i],"%d",&inpt);
      else if (strcmp(argv[i],"-skipstep2")==0)
	skipstep2=1;
      else if (strcmp(argv[i],"-makeps")==0)
	makeps=1;
      else if (strcmp(argv[i],"-nofiles")==0)
	writeFiles=false;
    }

  readParfile(psr,parFile,timFile,*npsr); /* Load the parameters       */
  readTimfile(psr,timFile,*npsr); /* Load the arrival times    */
  preProcess(psr,*npsr,argc,argv);

  for (i=0;i<2;i++)                   /* Do two iterations for pre- and post-fit residuals*/
    {
      formBatsAll(psr,*npsr);         /* Form the barycentric arrival times */
      formResiduals(psr,*npsr,1);    /* Form the residuals                 */
      if (i==0) doFit(psr,*npsr,0);   /* Do the fitting     */
      else textOutput(psr,*npsr,globalParameter,0,0,0,"");  /* Display the output */
    }

  //
  printf("Plugin to obtain a spectral model of pulsar timing residuals\n");
  doPlugin(psr,idt,ipw,ifc,iexp,inpt,makeps);

  return 0; 
} 

void doPlugin(pulsar *psr,double idt,int ipw,double ifc,double iexp,int inpt,int makeps)
{
  int i,j;

  double resx[MAX_OBSN],resy[MAX_OBSN],rese[MAX_OBSN]; // Timing residuals
  int    nres;                                         // Number of timing residuals
  double cubicVal[4],cubicErr[4];                      // Cubic fit to timing residuals
  double smoothModel[MAX_OBSN];                        // Smooth curve fitting the residuals
  double highFreqRes[MAX_OBSN];                        // High frequency residuals
  double expSmooth;                                    // Smoothing timescale
  double hfNormCovar[MAX_OBSN];                        // High frequency normalised covariance
  double hfZerolagNormCovar;                           // Zerolag covariance of HF residuals
  int hfNormCovarNpts[MAX_OBSN];                       // Number of covariances measured
  //
  double interpX[MAX_OBSN],interpY[MAX_OBSN];          // Interpolation of smooth curve
  int    nInterp;
  double origSpecX[MAX_OBSN],origSpecY[MAX_OBSN];      // Spectrum of raw data
  int nOrigSpec;
  double smoothSpecX0[MAX_OBSN],smoothSpecY0[MAX_OBSN];// 0-whitening of smooth curve
  int nSmoothSpec0;
  double smoothSpecX1[MAX_OBSN],smoothSpecY1[MAX_OBSN];// 1-whitening of smooth curve
  int nSmoothSpec1;
  double smoothSpecX2[MAX_OBSN],smoothSpecY2[MAX_OBSN];// 2-whitening of smooth curve
  int nSmoothSpec2;
  double highFreqSpecX[MAX_OBSN],highFreqSpecY[MAX_OBSN];// Spectrum of HF residuals
  int nHighFreqSpec;
  int usePreWhitening=0;                               // Prewhitening to use
  double preWhiteSpecX[MAX_OBSN],preWhiteSpecY[MAX_OBSN]; // Spectrum with final prewhitening
  double *covFunc;                                     // Covariance function
  int nPreWhiteSpec;
  double modelAlpha,modelFc,modelScale,nmodelScale;    // Model parameters
  int modelNfit=-1;
  double **uinv;                                       // Whitening matrix
  double **uinvI;
  double cholWhiteY[MAX_OBSN];                         // Cholesky white residuals
  double cholWspecX[MAX_OBSN],cholWspecY[MAX_OBSN];    // Cholesky whitened spectrum
  int    nCholWspec;
  double fitVar;

  int interpTime=14;                                   // Grid for interpolated values (days)
  int cont=1;
  double nSmooth;
  double zerolagRawCovar;
  int rawCovarNpts[MAX_OBSN];
  double rawCovar[MAX_OBSN];
  double zerolagWhiteCovar;
  int whiteCovarNpts[MAX_OBSN];
  double whiteCovar[MAX_OBSN];
  double cholSpecX[MAX_OBSN],cholSpecY[MAX_OBSN];
  int nCholSpec;
  double ampFit[MAX_OBSN],chisqFit[MAX_OBSN],bestAmp,bestLag,bestChisq;
  int nGridFit;
  double errorScaleFactor = 1;
  int tempTime=1;
  char dummy[100];

  verbose_calc_spectra=true;

  // Test the spectral analysis routine
  /*  {
    FILE *fin;
    long idum=-123;
    nres = 256;
    double outY_re[nres],outY_im[nres];

    fin = fopen("white.res","r");

    for (i=0;i<nres;i++)
      {
	resx[i] = i;
	//	resy[i] = TKgaussDev(&idum)*1.0e-6;
	fscanf(fin,"%lf",&resy[i]);
	rese[i] = 1.0e-6;
      }
    fclose(fin);
    TKspectrum(resx,resy,rese,nres,0,0,0,0,0,1,1,1,1,origSpecX,origSpecY,&nOrigSpec,0,0,outY_re,outY_im);    
    fileOutput2("spec1.dat",origSpecX,origSpecY,nOrigSpec);
    TKspectrum(resx,resy,rese,nres,0,0,0,0,0,2,1,1,1,origSpecX,origSpecY,&nOrigSpec,0,0,outY_re,outY_im);    
    fileOutput2("spec2.dat",origSpecX,origSpecY,nOrigSpec);
    TKspectrum(resx,resy,rese,nres,0,0,0,0,0,3,1,1,1,origSpecX,origSpecY,&nOrigSpec,0,0,outY_re,outY_im);    
    fileOutput2("spec3.dat",origSpecX,origSpecY,nOrigSpec);
    TKspectrum(resx,resy,rese,nres,0,0,0,0,0,4,1,1,1,origSpecX,origSpecY,&nOrigSpec,0,0,outY_re,outY_im);    
    fileOutput2("spec4.dat",origSpecX,origSpecY,nOrigSpec);
    TKspectrum(resx,resy,rese,nres,0,0,0,0,0,5,1,1,1,origSpecX,origSpecY,&nOrigSpec,0,0,outY_re,outY_im);    
    fileOutput2("spec5.dat",origSpecX,origSpecY,nOrigSpec);

    uinv= (double **)malloc(sizeof(double *)*(nres+1));
    for (i=0;i<nres+1;i++)uinv[i] = (double *)malloc(sizeof(double)*(nres+1));      
    for (i=0;i<nres;i++)
      {
	for (j=0;j<nres;j++)
	  {
	    if (i==j)
	      uinv[i][j]=1.0;
	    else
	      uinv[i][j]=0.0;
	  }
      }
    nOrigSpec = calcSpectra(uinv,resx,resy,nres,origSpecX,origSpecY,-1);
    fileOutput2("spec6.dat",origSpecX,origSpecY,nOrigSpec);
    exit(1);
    } */


  // Set up some defaults
  if (idt!=0) expSmooth = idt; 
  else expSmooth = 20;


  // Step 1
  do {
    // Step 1a: obtain time sorted post-fit residuals
    nres = obtainTimingResiduals(psr,resx,resy,rese);
    // Step 1b: remove mean from residuals (x and y)
    removeMean(resx,resy,nres);
    if(writeFiles)fileOutput3("tresiduals.dat",resx,resy,rese,nres);

    if (tempTime==1)
      {
	uinv= (double **)malloc(sizeof(double *)*(nres+1));
	covFunc = (double *)malloc(sizeof(double)*((int)(resx[nres-1]-resx[0])+5));
	for (i=0;i<nres+1;i++)uinv[i] = (double *)malloc(sizeof(double)*(nres+1));      
	tempTime=2;
      }

    // Step 1c: fit a cubic to the timing residuals
    cubicFit(resx,resy,rese,nres,cubicVal,cubicErr);
    // Step 1d: obtain a smooth curve that models the residuals well
    findSmoothCurve(resx,resy,rese,nres,cubicVal,smoothModel,expSmooth);
    if(writeFiles)fileOutput3("smoothCurve.dat",resx,smoothModel,rese,nres);
    // Step 1e: obtain high-freq. residuals
    getHighFreqRes(resy,smoothModel,nres,highFreqRes);
    if(writeFiles)fileOutput3("highFreqRes.dat",resx,highFreqRes,rese,nres);
    // Step 1f: obtain covariance of high-freq. residuals
    getHighFreqCovar(resx,rese,highFreqRes,nres,hfNormCovar,hfNormCovarNpts,&hfZerolagNormCovar);
    // Step 1g: plot the results
    plot1(resx,resy,rese,nres,cubicVal,smoothModel,highFreqRes,hfNormCovar,hfNormCovarNpts,hfZerolagNormCovar);
    if (idt!=0) cont=0;
    else {
      printf("smooth = %g days. Press 0 to continue, or another number to update the smooth\n",expSmooth);
      scanf("%lf",&nSmooth);
      if (nSmooth==0) cont=0;
      else expSmooth = nSmooth;
    }
  } while (cont==1);


  if(!skipstep2){
  // Step 2:

  // Put errors into uinv matrix
  for (i=0;i<nres;i++)
    {
      for (j=0;j<nres;j++)	
	{
	  if (i==j)
	    uinv[i][j]=1.0/(rese[i]);
	  else
	    uinv[i][j]=0.0;
	}
    }

  // Step 2a: Obtain spectra of original residuals without any prewhitening
  //  nOrigSpec = calculateSpectra(resx,resy,rese,nres,1,0,1,origSpecX,origSpecY);
  nOrigSpec = calcSpectra(uinv,resx,resy,nres,origSpecX,origSpecY,-1);
  if(writeFiles)fileOutput2("origSpectra.dat",origSpecX,origSpecY,nOrigSpec);

  // Step 2b: interpolate the smooth curve
  interpolate(resx,resy,rese,nres,cubicVal,interpX,interpY,
	      &nInterp,interpTime,expSmooth);

  // Step 2c: Obtain spectra of smooth interpolated model without any prewhitening
  // Errors are ignored
  //  nSmoothSpec0 = calculateSpectra(interpX,interpY,rese,nInterp,0,0,2,
  //  				  smoothSpecX0,smoothSpecY0);
  uinvI = (double **)malloc(sizeof(double *)*(nInterp+1));
  for (i=0;i<nInterp+1;i++) uinvI[i] = (double *)malloc(sizeof(double)*(nInterp+1));      
  for (i=0;i<nInterp;i++)
    {
      for (j=0;j<nInterp;j++)
	{
	  if (i==j) uinvI[i][j]=1.0;
	  else	    uinvI[i][j]=0.0;
	}
    }
  printf("Calculating spectra without prewhitening\n");
  nSmoothSpec0 = calculateSpectra(interpX,interpY,rese,nInterp,0,0,2,
				  smoothSpecX0,smoothSpecY0);
  if(writeFiles)fileOutput2("zeroprewhite.dat",smoothSpecX0,smoothSpecY0,nSmoothSpec0);

  //  nSmoothSpec0 = calcSpectra(uinvI,interpX,interpY,nInterp,smoothSpecX0,smoothSpecY0,-1);
  printf("Done calculating spectra\n");
  if(writeFiles)fileOutput2("zeroprewhite.dat",smoothSpecX0,smoothSpecY0,nSmoothSpec0);
  // TESTING
  //  nSmoothSpec0 = calcSpectra(uinv,resx,resy,rese,nres,
  //			     smoothSpecX0,smoothSpecY0);

  // Step 2d: Obtain spectra of smooth interpolated model with 1st order prewhitening
  nSmoothSpec1 = calculateSpectra(interpX,interpY,rese,nInterp,0,1,2,
				  smoothSpecX1,smoothSpecY1);
  if(writeFiles)fileOutput2("oneprewhite.dat",smoothSpecX1,smoothSpecY1,nSmoothSpec1);
  // Step 2e: Obtain spectra of smooth interpolated model with 2nd order prewhitening
  nSmoothSpec2 = calculateSpectra(interpX,interpY,rese,nInterp,0,2,2,
				  smoothSpecX2,smoothSpecY2);
  if(writeFiles)fileOutput2("twoprewhite.dat",smoothSpecX2,smoothSpecY2,nSmoothSpec2);
  // Step 2f: Obtain spectra of high frequency residuals
  if(writeFiles)
  {
    long seed= -123;
    FILE *fout = fopen("highfreqresiduals.dat","w");
    for (i=0;i<nres;i++)
      {
	//highFreqRes[i] = TKgaussDev(&seed)*rese[i];
	fprintf(fout,"%g %g %g\n",resx[i],highFreqRes[i],rese[i]);
      }
    fclose(fout);
  }
  //  nHighFreqSpec = calculateSpectra(resx,highFreqRes,rese,nres,1,0,1,highFreqSpecX,
  //				   highFreqSpecY);
  nHighFreqSpec = calcSpectra(uinv,resx,highFreqRes,nres,highFreqSpecX,highFreqSpecY,-1);
  if(writeFiles)fileOutput2("highfreqspec.dat",highFreqSpecX,highFreqSpecY,nHighFreqSpec);

  // Step 2g: make the plot
  plot2(origSpecX,origSpecY,nOrigSpec,smoothSpecX0,smoothSpecY0,nSmoothSpec0,
	smoothSpecX1,smoothSpecY1,nSmoothSpec1,smoothSpecX1,smoothSpecY2,nSmoothSpec2,
	highFreqSpecX,highFreqSpecY,nHighFreqSpec,makeps);


  }
  // Step 3: select a prewhitening
  if (ipw==-1){
    printf("Select prewhitening required (0,1,2) (type -1 to obtain covariance function from the data) ");
    scanf("%d",&usePreWhitening);
  }
  else
    usePreWhitening=ipw;

  if (usePreWhitening!=-1) // If we're calculating the covariance function from a spectrum
    {
      float mx,my;
      // Step 3a: obtain spectra with this prewhitening
      nPreWhiteSpec = calculateSpectra(interpX,interpY,rese,nInterp,0,usePreWhitening,2,
				       preWhiteSpecX,preWhiteSpecY);
      // Step 3b: plot spectra
      cont=1;
      do {
	plot3(preWhiteSpecX,preWhiteSpecY,nPreWhiteSpec,usePreWhitening,
	      highFreqSpecX,highFreqSpecY,nHighFreqSpec,modelAlpha,modelFc,modelNfit,modelScale,1,&mx,&my);
	// Step 3c: Fit to spectra
	cont = fitSpectra(preWhiteSpecX,preWhiteSpecY,nPreWhiteSpec,&modelAlpha,&modelFc,&modelNfit,&modelScale,&fitVar,0,ipw,ifc, iexp, inpt);
      } while (cont==1);

      // Step 4a: calculate the Cholesky whitening matrix (uinv)
      calculateCholesky(modelAlpha,modelFc,modelScale,fitVar,uinv,covFunc,resx,resy,rese,nres,highFreqRes,&errorScaleFactor);
    }
  else // Calculate covariance function from the data
    {
      double tt;
      // Step 3a: calculate covariance function of the raw data
      printf("Step 1\n");
      calculateDailyCovariance(resx,resy,rese,nres,rawCovar,rawCovarNpts,&zerolagRawCovar,1);
      //      getHighFreqCovar(resx,rese,resy,nres,rawCovar,rawCovarNpts,&zerolagRawCovar);
      // Step 3b: fit for an exponential function
      printf("Step 2 %g\n",zerolagRawCovar);
      fitExponential(resx,nres,rawCovar,rawCovarNpts,ampFit,chisqFit,&bestAmp,&bestLag,&bestChisq,&nGridFit);
      printf("Do plot\n");
      do {
	plot3a(resx,resy,nres,rawCovar,rawCovarNpts,zerolagRawCovar,ampFit,chisqFit,nGridFit,bestAmp,bestLag,bestChisq,makeps);
	printf("Chosen lag = %g (press '-1' to continue or type in a new lag) ",bestLag); scanf("%lf",&tt);
	if (tt!=-1) {
	  bestLag=tt;
	  // Find closest
	  bestAmp = ampFit[(int)(tt+0.5)];
	  bestChisq = chisqFit[(int)(tt+0.5)];
	}
      } while (tt!=-1);
      calculateCholeskyCovarFunc(bestAmp,bestLag,nGridFit,uinv,resx,resy,rese,nres,covFunc);
      //      exit(1);
    }
  // Step 4c: get white residuals using the Cholesky matrix
  getWhiteRes(resx,resy,rese,nres,uinv,cholWhiteY);
  if(writeFiles)fileOutput3("cholWhiteRes.dat",resx,cholWhiteY,rese,nres);
  // Spec 4d: get a spectrum of the whitened data
  nCholWspec = calculateSpectra(resx,cholWhiteY,rese,nres,0,0,2,
				  cholWspecX,cholWspecY);
  //  fileOutput2("cholWhiteSpec.dat",cholWspecX,cholWspecY,nCholWspec);
  // Step 4e: get covariance of white residuals
  calculateDailyCovariance(resx,cholWhiteY,rese,nres,whiteCovar,whiteCovarNpts,&zerolagWhiteCovar,0);
  // Step 4f: plot
  plot4(resx,resy,rese,nres,cholWhiteY,whiteCovar,whiteCovarNpts,zerolagWhiteCovar);
  if (inpt==-1) {printf("Continue (press '1') "); scanf("%s",dummy);}

  // Step 5: now improve the spectral estimate
  // Step 5a: Obtain a spectrum with the whitening routine
  printf("Forming spectrum of whitened data\n");

  /*  {
    FILE *fin;
    fin = fopen("/u/hob044/uinv1.dat","r");
    for (i=0;i<nres;i++)
      {
	for (j=0;j<nres;j++)
	  fscanf(fin,"%lf",&uinv[i][j]);
      }
    
    fclose(fin);
    
    }*/

  nCholSpec = calcSpectra(uinv,resx,resy,nres,cholSpecX,cholSpecY,-1);
  fileOutput2("cholSpectra.dat",cholSpecX,cholSpecY,nCholSpec);

  // Step 5b: refit the model
  if (usePreWhitening!=-1) // If we're calculating the covariance function from a spectrum
    {
      fitSpectra(cholSpecX,cholSpecY,nCholSpec,&modelAlpha,&modelFc,&modelNfit,&nmodelScale,&fitVar,1,ipw,ifc, iexp, inpt);
      plot5(preWhiteSpecX,preWhiteSpecY,nPreWhiteSpec,usePreWhitening,highFreqSpecX,highFreqSpecY,nHighFreqSpec,
	    modelAlpha,modelFc,modelNfit,modelScale,nmodelScale,cholSpecX,cholSpecY,nCholSpec,cholWspecX,cholWspecY,nCholWspec,makeps);

      // Step 5c: recalculate the Cholesky matrix
      calculateCholesky(modelAlpha,modelFc,nmodelScale,fitVar,uinv,covFunc,resx,resy,rese,nres,highFreqRes,&errorScaleFactor);
    }
  else
    plot6(cholSpecX,cholSpecY,nCholSpec,cholWspecX,cholWspecY,nCholWspec,highFreqSpecX,highFreqSpecY,nHighFreqSpec,makeps);

  // Step 6: output the covariance function
  outputCovarianceFunction(covFunc,(int)(resx[nres-1]-resx[0])+2,errorScaleFactor,psr);
  //    outputMatrix(uinv,nres);
  
  // Deallocate memory 
  for (i=0;i<nres+1;i++) free(uinv[i]);
  free(uinv);
  for (i=0;i<nInterp+1;i++) free(uinvI[i]);
  free(uinvI);
  free(covFunc);
}

void outputCovarianceFunction(double *covFunc,int n,double errorScaleFactor,pulsar* psr)
{
  FILE *fout;
  char fname[100];
  int i;

  sprintf(fname,"covarFunc.dat_%s",psr[0].name);

  if (!(fout = fopen(fname,"w")))
    {
      printf("Unable to open output file: %s\n",fname);
      exit(1);
    }
  fprintf(fout,"%.15g\n",errorScaleFactor);
  for (i=0;i<n;i++)
    {
      fprintf(fout,"%.15g\n",covFunc[i]);
    }
  fclose(fout);
}

void removeMean(double *resx,double *resy,int n)
{
  double meanx,meany;
  double maxx,minx;
  int i;
  maxx = TKfindMax_d(resx,n);
  minx = TKfindMin_d(resx,n);
  meany = TKmean_d(resy,n);
  for (i=0;i<n;i++)
    {
      resx[i] -= (maxx+minx)*0.5;
      resy[i] -= meany;
    }
}

void fileOutput3(char *fname,double *x,double *y,double *z,int n)
{
  FILE *fout;
  int i;
  if (!(fout = fopen(fname,"w")))
    {
      printf("Unable to open file >%s< for output\n",fname);
      exit(1);
    }
  for (i=0;i<n;i++)
    fprintf(fout,"%g %g %g\n",x[i],y[i],z[i]);
  fclose(fout);
}

void fileOutput2(char *fname,double *x,double *y,int n)
{
  FILE *fout;
  int i;
  if (!(fout = fopen(fname,"w")))
    {
      printf("Unable to open file >%s< for output\n",fname);
      exit(1);
    }
  for (i=0;i<n;i++)
    fprintf(fout,"%g %g\n",x[i],y[i]);
  fclose(fout);
}

void calculateCholeskyCovarFunc(double bestAmp,double bestLag,int nGridFit,double **uinv,double *resx,
				double *resy,double *rese,int nres,double *covarFunc)
{
  int ndays = (int)(ceil(resx[nres-1])-floor(resx[0])+1)+2; // Add two extra days for interpolation  
  int i,j;
  double tt;
  int debug=1;

  for (i=0;i<ndays;i++)
    covarFunc[i] = bestAmp*exp(-(double)i/bestLag);
  tt = covarFunc[0];
  //  for (i=0;i<ndays;i++)
  //    covarFunc[i] = covarFunc[i]*pow(86400.0*365.25,2)/tt*1.0e-12;
  if (debug==1)
    {
      FILE *fout;
      fout = fopen("covarfunc","w");
      for (i=0;i<ndays;i++)
	fprintf(fout,"%g %g\n",(double)(i+1),covarFunc[i]);
      fclose(fout);
    }
  //      c[i]=c[i]*pow(86400.0*365.25,2)/tt*actVar; 
  formCholeskyMatrix_pl(covarFunc,resx,resy,rese,nres,uinv);
}

// Do a grid search for minimum in chisq for fitting an exponential function
void fitExponential(double *resx,int nres,
		    double *rawCovar,int *rawCovarNpts,double *ampFit,double *chisqFit,double *bestAmp,
		    double *bestLag,double *bestChisq,int *nGridFit)
{
  int i,j;
  int nc=0;
  int dspan=(int)(resx[nres-1]-resx[0]+0.5);
  double lag;
  double tl,bl;
  double x[dspan],y[dspan],e[dspan];
  int foundMin=0;

  for (i=1;i<dspan;i++)
    {
      if (rawCovarNpts[i] > 0)
	{
	  x[nc]=i; // Fitting linearly with x
	  y[nc]=rawCovar[i];
	  e[nc]=1;
	  nc++;
	}
    }
  
  // Do the grid search
  for (i=0;i<nc;i++)
    {
      lag = (double)x[i];
      tl = 0;
      bl = 0;
      for (j=0;j<nc;j++)
	{
	  tl += y[j]*exp(-x[j]/lag)/e[j];
	  bl += exp(-2*x[j]/lag)/e[j];
	}
      ampFit[i] = tl/bl;
      // Calculate chisq
      chisqFit[i] = 0.0;
      for (j=0;j<nc;j++)
	chisqFit[i]+=pow((y[j]-ampFit[i]*exp(-x[j]/lag))/e[j],2);
      //      printf("ampFit = %g %g %g\n",ampFit[i],chisqFit[i],lag);
      //
      // Find first minimum
      //
      //            printf("Have %g %g\n",lag,chisqFit[i]);
      if (i==0)
	{
	  *bestLag=lag;
	  *bestAmp=ampFit[i];
	  *bestChisq = chisqFit[i];
	}
      else if (chisqFit[i] < *bestChisq && foundMin==0)
	{
	  *bestChisq = chisqFit[i];
	  *bestLag=lag;
	  *bestAmp=ampFit[i];	  
	}
      else if (chisqFit[i] > *bestChisq && foundMin==0)
	foundMin=1;
    }
  *nGridFit = nc;
  //  printf("Returning %g %g %g %g\n",*bestLag,*bestAmp,*bestChisq,(double)(*nGridFit));
}

void plot3a(double *resx,double *resy,int nres,double *rawCovar,int *rawCovarNpts,double zerolagRawCovar,
	    double *ampFit,double *fitChisq,int nGridFit,double bestAmp,double bestLag,double bestChisq,
	    int makeps)
{
  int dspan=(int)(resx[nres-1]-resx[0]+0.5);
  float fx[dspan],fy[dspan];
  float fx2[10],fy2[10];
  float fx3[nGridFit],fy3[nGridFit],fy4[nGridFit];
  float fy5[dspan];
  float fx6[dspan],fy6[dspan];
  float minx,maxx,miny,maxy;
  int i,j,np,ncovar;
  int nc=0,nc2=0;

  for (i=1;i<dspan;i++)
    {
      if (rawCovarNpts[i] > 0)
	{
	  fx[nc]=log10(i);
	  fy[nc]=rawCovar[i];
	  fy5[nc] = bestAmp*exp(-pow(10,fx[nc])/bestLag);
	  nc++;
	}
    }
  nc2=0;

  for (i=1;i<dspan;i++)
    {
      if (rawCovarNpts[i] > 0)
	{
	  fx3[nc2] = log10(i);
	  fy3[nc2] = ampFit[nc2];
	  fy4[nc2] = fitChisq[nc2];      
	  nc2++;
	}
    }
  minx = TKfindMin_f(fx,nc);
  maxx = TKfindMax_f(fx,nc);


  // WARNING REMOVE
  //  zerolagRawCovar = 8.5e-11;

  miny = -2*fabs(zerolagRawCovar);//TKfindMin_f(fy,nc);
  maxy = 2*fabs(zerolagRawCovar);//TKfindMax_f(fy,nc);
  printf("Here with %g %g\n",miny,maxy);
  if (makeps==1)
    {
      int addi;
      cpgbeg(0,"spectralPlot3a.ps/ps",1,1);
      cpgsch(2);
      cpgpap(0,0.400);
      cpgsch(2);
      cpgsfs(2);
      cpgslw(2);
      //      cpgsch(1.4);  cpgsfs(2);  cpgslw(2);
      printf("MIN/MAX = %g %g %g %g\n",minx,maxx,miny,maxy);
      cpgenv(minx,maxx,miny/1.3,maxy/1.3,0,10);
      cpglab("Lag (d)","Covariance","");
      cpgtext(0.1,-1e-10,"(b)");
      //      cpgpt(nc,fx,fy,1);

      ncovar=0;
      addi=1;
      for (i=1;i<dspan;i+=addi)
	{
	  np = 0;
	  fx6[ncovar] = 0.0;
	  fy6[ncovar] = 0.0;
	  printf("Have %d %d\n",i,addi);
	  for (j=i;j<i+addi;j++)
	    {
	      if (rawCovarNpts[j] > 0)
		{
		  fx6[ncovar] += j*rawCovarNpts[j];
		  fy6[ncovar] += (rawCovar[j]*rawCovarNpts[j]);
		  np+=rawCovarNpts[j];
		}
	    }
	  if (np>0)
	    {
	      fx6[ncovar]=log10(fx6[ncovar]/(double)np);
	      fy6[ncovar]/=(double)np;
	      ncovar++;
	    }
	  if (i==10 && addi==1) {i=0; addi=10;}
	  if (i==100 && addi==10) {i=0; addi=100;}
	  if (i==1000 && addi==100) {i=0; addi=1000;}
	}
      cpgsci(1); cpgpt(ncovar,fx6,fy6,5);   cpgsci(1);

            cpgsci(1); cpgsls(1); cpgline(nc,fx,fy5); cpgsci(1); cpgsls(1);
      fx2[0] = minx;
      fx2[1] = maxx;
      fy2[0] = 0;
      fy2[1] = 0;
      cpgsls(1); cpgline(2,fx2,fy2);
      fx2[0] = minx;
      fy2[0] = zerolagRawCovar;
       cpgsch(3); cpgsci(1); cpgpt(1,fx2,fy2,23); cpgsch(1.4); cpgsci(1);            
      cpgend();
    }

  cpgbeg(0,"/xs",1,1);
  cpgsch(1.4);
  cpgsfs(2);
  cpgslw(2);
  //  cpgenv(minx,maxx,miny,maxy,0,10);
  cpgsvp(0.1,0.95,0.6,0.95);
  cpgswin(minx,maxx,miny,maxy);
  cpgsch(1);
  cpgbox("BCTLS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("","Covariance","");
  cpgsch(1.4);
  cpgpt(nc,fx,fy,20);
  cpgsci(3); cpgsls(3); cpgline(nc,fx,fy5); cpgsci(1); cpgsls(1);
  fx2[0] = minx;
  fy2[0] = zerolagRawCovar;
  cpgsch(2); cpgsci(2); cpgpt(1,fx2,fy2,15); cpgsch(1.4); cpgsci(1);

  // Plot chisq
  cpgsvp(0.1,0.95,0.35,0.6);
  miny = TKfindMin_f(fy4,nc2);
  maxy = TKfindMax_f(fy4,nc2);
  cpgswin(minx,maxx,miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgsch(1);
  cpgbox("BCTLS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("","Chisq","");
  cpgsch(1.4);
  cpgsci(2); cpgline(nc2,fx3,fy4); cpgsci(1);
  fx2[0] = log10(bestLag); fy2[0] = bestChisq;
  printf("Plotting at %g %g %g\n",bestLag,bestChisq,bestAmp);
  cpgsch(2); cpgsci(2); cpgpt(1,fx2,fy2,15); cpgsch(1.4); cpgsci(1);

  cpgsvp(0.1,0.95,0.1,0.35);
  miny = TKfindMin_f(fy3,nc2);
  maxy = TKfindMax_f(fy3,nc2);
  cpgswin(minx,maxx,miny,maxy);
  cpgsch(1);
  cpgbox("BCTNLS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("Lag (d)","A","");
  cpgsch(1.4);
  cpgsci(2); cpgline(nc2,fx3,fy3); cpgsci(1);
  fx2[0] = log10(bestLag); fy2[0] = bestAmp;
  cpgsch(2); cpgsci(2); cpgpt(1,fx2,fy2,15); cpgsch(1.4); cpgsci(1);

  cpgend();
}

void outputMatrix(double **uinv,int nres)
{
  int i,j;
  FILE *fout;

  fout = fopen("/DATA/BRAHE_1/hob044/idcm.dat","w");
  for (i=0;i<nres;i++)
    {
      for (j=0;j<nres;j++)
	fprintf(fout,"%.15g ",uinv[i][j]);
    }
  fclose(fout);


}

void plot6(double *cholSpecX,double *cholSpecY,int nCholSpec,double *cholWspecX,
	   double *cholWspecY,int nCholWspec,double *highFreqSpecX,
	   double *highFreqSpecY,int nHighFreqSpec,int makeps)
{
  int i,j;
  float fx[nCholSpec],fy[nCholSpec];
  float fx2[nCholSpec],fy2[nCholSpec];
  float fx3[nHighFreqSpec],fy3[nHighFreqSpec];
  float minx,maxx,miny,maxy;
  FILE *fout;

  fout = fopen("cholWhiteSpec.dat","w");
  printf("In plot 6\n");
  for (i=0;i<nCholSpec;i++)
    {
      fx[i] = log10(cholSpecX[i]*365.25);
      fy[i] = log10(cholSpecY[i]);
    }
  for (i=0;i<nCholWspec;i++)
    {
      fx2[i] = log10(cholWspecX[i]*365.25);
      fy2[i] = log10(cholWspecY[i]*pow(365.25*86400,2));
      fprintf(fout,"%g %g\n",cholWspecX[i],pow(10,fy2[i]));
    }
  fclose(fout);
  for (i=0;i<nHighFreqSpec;i++)
    {
      fx3[i] = log10(highFreqSpecX[i]*365.25);
      fy3[i] = log10(highFreqSpecY[i]);
    }
  minx = TKfindMin_f(fx,nCholSpec);
  maxx = TKfindMax_f(fx,nCholSpec);
  miny = TKfindMin_f(fy,nCholSpec);
  maxy = TKfindMax_f(fy,nCholSpec);

  cpgbeg(0,"/xs",1,1);
  cpgsvp(0.1,0.95,0.45,0.95);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgbox("BCLTS",0,0,"BCNTS",0,0);
  cpglab("","Power Spectral Density (yr\\u3\\d)","");
  cpgsci(7); cpgline(nCholSpec,fx,fy); cpgpt(nCholSpec,fx,fy,20); cpgsci(1);
  cpgsci(1); cpgline(nHighFreqSpec,fx3,fy3); cpgpt(nHighFreqSpec,fx3,fy3,20); cpgsci(1);
  for (i=(int)(miny-0.1*(maxy-miny))-1;i<(int)maxy+1;i++)
    {
      fx[0] = minx-0.1*(maxx-minx); fx[1] = maxx+0.1*(maxx-minx);
      for (j=0;j<10;j++)
	{
	  fy[0] = fy[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }
  for (i=(int)(minx-0.1*(maxx-minx))-1;i<(int)maxx+1;i++)
    {
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      for (j=0;j<10;j++)
	{
	  fx[0] = fx[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }



  minx = TKfindMin_f(fx2,nCholWspec);
  maxx = TKfindMax_f(fx2,nCholWspec);
  miny = TKfindMin_f(fy2,nCholWspec);
  maxy = TKfindMax_f(fy2,nCholWspec);
  cpgsvp(0.1,0.95,0.10,0.45);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgbox("BCNLTS",0,0,"BCNTS",0,0);
  cpglab("Frequency (yr\\u-1\\d)","Power Spectral Density (yr)","");
  cpgsci(2); cpgline(nCholWspec,fx2,fy2); cpgpt(nCholWspec,fx2,fy2,20); cpgsci(1);
  for (i=(int)(miny-0.1*(maxy-miny))-1;i<(int)maxy+1;i++)
    {
      fx[0] = minx-0.1*(maxx-minx); fx[1] = maxx+0.1*(maxx-minx);
      for (j=0;j<10;j++)
	{
	  fy[0] = fy[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }
  for (i=(int)(minx-0.1*(maxx-minx))-1;i<(int)maxx+1;i++)
    {
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      for (j=0;j<10;j++)
	{
	  fx[0] = fx[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }
  fx[0] = minx-0.1*(maxx-minx); fx[1] = maxx+0.1*(maxx-minx);
  fy[0] = fy[1] = log10(1.0/pow(10,fx2[nCholWspec-1]));
  cpgsci(3); cpgline(2,fx,fy);
  fy[0] = fy[1] = log10(3.0/pow(10,fx2[nCholWspec-1]));
  cpgsci(3); cpgline(2,fx,fy);
  fy[0] = fy[1] = log10(0.05/pow(10,fx2[nCholWspec-1]));
  cpgsci(3); cpgline(2,fx,fy);
  cpgsci(1);
  cpgend();

  if (makeps==1)
    {
      cpgbeg(1,"spectralPlot6a.ps/ps",1,1);
      cpgsch(2.0);
      cpgpap(0,0.400);
      cpgsch(2); cpgsfs(2); cpgslw(2);
      // Plot the white data spectrum
      cpgenv(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny),0,10);
      cpglab("Frequency (yr\\u-1\\d)","log\\d10\\u[Spectral density (yr)]","");
      cpgtext(-1.1,-3,"(c)");
      cpgsci(7); cpgline(nCholWspec,fx2,fy2); 
      cpgpt(nCholWspec,fx2,fy2,20); cpgsci(1);
      
      fx[0] = minx-0.1*(maxx-minx); fx[1] = maxx+0.1*(maxx-minx);
      fy[0] = fy[1] = log10(1.0/pow(10,fx2[nCholWspec-1]));
      cpgsls(4); cpgline(2,fx,fy);
      fy[0] = fy[1] = log10(3.0/pow(10,fx2[nCholWspec-1]));
      cpgsls(4); cpgline(2,fx,fy);
      fy[0] = fy[1] = log10(0.05/pow(10,fx2[nCholWspec-1]));
      cpgsls(4); cpgline(2,fx,fy);
      cpgsls(1);
      fx[0] = fx[1] = 0;
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      cpgsls(4); cpgline(2,fx,fy); cpgsls(1);
      cpgend();
      
    }

}

void plot5(double *preWhiteSpecX,double *preWhiteSpecY,int nPreWhiteSpec,
	   int usePreWhitening,double *highFreqSpecX,double *highFreqSpecY,int nHighFreqSpec,
	   double modelAlpha,double modelFc,int modelNfit,double modelScale,
	   double nmodelScale,double *cholSpecX,double *cholSpecY,int nCholSpec,
	   double *cholWspecX,double *cholWspecY,int nCholWspec,int makeps)
{
  int i,j;
  float fx[MAX_OBSN],fy[MAX_OBSN];
  float fx1[MAX_OBSN],fy1[MAX_OBSN];
  float fx2[nCholSpec],fy2[nCholSpec];
  float fx3[nCholWspec],fy3[nCholWspec];
  float minx,maxx,miny,maxy;
  FILE *fout1,*fout2,*fout;

  // First do exactly the same as plot3
  cpgbeg(0,"/xs",1,1);
  cpgask(0);
  cpgsch(1);
  cpgsfs(2);
  cpgslw(2);

  plot3(preWhiteSpecX,preWhiteSpecY,nPreWhiteSpec,usePreWhitening,highFreqSpecX,highFreqSpecY,
	nHighFreqSpec, modelAlpha, modelFc, modelNfit, modelScale,0,&minx,&maxx);
  // Overlay spectrum obtained using Cholesky
  
  // Overlay new model
  for (i=0;i<nCholSpec;i++)
    {
      fx1[i] = log10(cholSpecX[i]*365.25);
      fy1[i] = log10(cholSpecY[i]);
    }
  cpgsci(7); cpgline(nCholSpec,fx1,fy1); 
  cpgpt(nCholSpec,fx1,fy1,20); cpgsci(1);

  // Now overplot the new model
    {
      for (i=0;i<nCholSpec;i++)
	{
	  fx2[i] = log10(cholSpecX[i]*365.25);
	  //	  fy2[i] = nmodelScale-log10(pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0));
	  fy2[i] = log10(nmodelScale*(1.0/pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0)));
	  //	  fy2[i] = log10(pow(10,nmodelScale)/365.25)-log10(pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0));
	}
      cpgsls(2); cpgsci(2); cpgline(nCholSpec,fx2,fy2); cpgsci(1); cpgsls(1);
    }
    printf("New model spectrum = %g\n",nmodelScale);
    //
    fout = fopen("cholWhiteSpec.dat","w");
  for (i=0;i<nCholWspec;i++)
    {
      fx3[i] = log10(cholWspecX[i]*365.25);
      fy3[i] = log10(cholWspecY[i]*pow(365.25*86400,2));
      fprintf(fout,"%g %g\n",cholWspecX[i],pow(10,fy3[i]));
    }
  fclose(fout);
  //  minx = TKfindMin_f(fx3,nCholWspec);
  //  maxx = TKfindMax_f(fx3,nCholWspec);
  miny = TKfindMin_f(fy3,nCholWspec);
  maxy = TKfindMax_f(fy3,nCholWspec);

  cpgsvp(0.1,0.95,0.15,0.45);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgbox("BCNLTS",0,0,"BCNTS",0,0);

  cpglab("Frequency (yr\\u-1\\d)","Power Spectral Density (yr)","");
  for (i=(int)(miny-0.1*(maxy-miny))-1;i<(int)maxy+1;i++)
    {
      fx[0] = minx-0.1*(maxx-minx); fx[1] = maxx+0.1*(maxx-minx);
      for (j=0;j<10;j++)
	{
	  fy[0] = fy[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }
  for (i=(int)(minx-0.1*(maxx-minx))-1;i<(int)maxx+1;i++)
    {
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      for (j=0;j<10;j++)
	{
	  fx[0] = fx[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }

  cpgsci(7); cpgline(nCholWspec,fx3,fy3); 
  cpgpt(nCholWspec,fx3,fy3,20); cpgsci(1);

  fx[0] = minx; fx[1] = maxx;
  fy[0] = fy[1] = log10(1.0/pow(10,fx3[nCholWspec-1]));
  cpgsci(3); cpgline(2,fx,fy);
  fy[0] = fy[1] = log10(3.0/pow(10,fx3[nCholWspec-1]));
  cpgsci(3); cpgline(2,fx,fy);
  fy[0] = fy[1] = log10(0.05/pow(10,fx3[nCholWspec-1]));
  cpgsci(3); cpgline(2,fx,fy);
  cpgsci(1);
  cpgend();

  if (makeps==1) // Make plot for paper
    {
      float nx1[MAX_OBSN],ny1[MAX_OBSN];
      float nx2[MAX_OBSN],ny2[MAX_OBSN];

      fout1 = fopen("model1.dat","w");
      fout2 = fopen("model2.dat","w");
      cpgbeg(1,"spectralPlot5a.ps/ps",1,1);
      cpgsch(2.0);
      cpgpap(0,0.400);
      cpgsch(2); cpgsfs(2); cpgslw(2);
      // Plot the white data spectrum
      cpgenv(-1.2,1,miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny),0,10);
      //      cpgenv(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny),0,10);
      cpglab("Frequency (yr\\u-1\\d)","log\\d10\\u[Power spectral density (yr)]","");
      cpgtext(-1.1,-0.2,"(c)");
      cpgsci(7); cpgline(nCholWspec,fx3,fy3); 
      cpgpt(nCholWspec,fx3,fy3,20); cpgsci(1);
      
      fx[0] = minx-0.1*(maxx-minx); fx[1] = maxx+0.1*(maxx-minx);
      fy[0] = fy[1] = log10(1.0/pow(10,fx3[nCholWspec-1]));
      cpgsls(4); cpgline(2,fx,fy);
      fy[0] = fy[1] = log10(3.0/pow(10,fx3[nCholWspec-1]));
      cpgsls(4); cpgline(2,fx,fy);
      fy[0] = fy[1] = log10(0.05/pow(10,fx3[nCholWspec-1]));
      cpgsls(4); cpgline(2,fx,fy);
      cpgsls(1);
      fx[0] = fx[1] = 0;
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      cpgsls(4); cpgline(2,fx,fy); cpgsls(1);
      cpgend();
	
      // Plot the high freq res. and Cholesky spectrum
      cpgbeg(1,"spectralPlot5b.ps/ps",1,1);
      cpgsch(2.0);
      cpgpap(0,0.400);
      cpgsch(2); cpgsfs(2); cpgslw(2);
      miny = TKfindMin_f(fy2,nCholSpec);
      maxy = TKfindMax_f(fy2,nCholSpec);
      for (i=0;i<nHighFreqSpec;i++)
	{
	  nx1[i] = log10(highFreqSpecX[i]*365.25);
	  ny1[i] = log10(highFreqSpecY[i]);
	  if (ny1[i] > maxy) maxy = ny1[i];
	  if (ny1[i] < miny) miny = ny1[i];
	}
      // Also have fx1, fy1;
      //      cpgenv(minx,maxx,miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny),0,10);
      cpgenv(-1.2,1,miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny),0,10);
      cpglab("Frequency (yr\\u-1\\d)","log\\d10\\u[Power spectral density (yr\\u3\\d)]","");
      cpgtext(-1.1,-19,"(d)");
      cpgsls(4); cpgline(nHighFreqSpec,nx1,ny1); // cpgpt(nHighFreqSpec,nx1,ny1,16);
      cpgsls(1); cpgline(nCholSpec,fx1,fy1); cpgsls(1);
      cpgline(nCholSpec,fx2,fy2);
      // old model
      for (i=0;i<nCholSpec;i++)
	{
	  fx2[i] = log10(cholSpecX[i]*365.25);
	  //	  fy2[i] = nmodelScale-log10(pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0));

	  fy2[i] = log10(nmodelScale*(1.0/pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0)));
	  fprintf(fout2,"%g %g\n",cholSpecX[i],pow(10,fy2[i]));

	  fy2[i] = log10(modelScale*(1.0/pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0)));
	  fprintf(fout1,"%g %g\n",cholSpecX[i],pow(10,fy2[i]));
	}
      cpgsls(2); cpgsci(2); cpgline(nCholSpec,fx2,fy2); cpgsci(1); cpgsls(1);
      fx[0] = fx[1] = 0;
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      cpgsls(4); cpgline(2,fx,fy); cpgsls(1);

      cpgend();
      fclose(fout1); fclose(fout2);

      //      plot3(preWhiteSpecX,preWhiteSpecY,nPreWhiteSpec,usePreWhitening,highFreqSpecX,highFreqSpecY,
      //	    nHighFreqSpec, modelAlpha, modelFc, modelNfit, modelScale,0);
  // Overlay spectrum obtained using Cholesky
  
  // Overlay new model
  //  for (i=0;i<nCholSpec;i++)
  //    {
  //      fx[i] = log10(cholSpecX[i]*365.25);
  //      fy[i] = log10(cholSpecY[i]);
  //    }


      
    }
  
}


void plot4(double *resx,double *resy,double *rese,int nres,double *cholWhiteY,
	   double *whiteCovar,int *whiteCovarNpts,double zerolagWhiteCovar)
{
  int dspan=(int)(resx[nres-1]-resx[0]+0.5);
  float fx1[nres],fy1[nres],fy1e1[nres],fy1e2[nres];
  float fx2[nres],fy2[nres];
  float fx3[dspan],fy3[dspan];
  float minx,maxx,miny,maxy;
  int nc=0;
  int i;

  for (i=0;i<nres;i++)
    {
      fx1[i] = fx2[i] = (float)resx[i];
      fy1[i] = (float)resy[i];
      fy2[i] = (float)cholWhiteY[i];
      fy1e1[i] = fy1[i] - (float)rese[i];
      fy1e2[i] = fy1[i] + (float)rese[i];
    }
  for (i=1;i<dspan;i++)
    {
      if (whiteCovarNpts[i] > 0)
	{
	  fx3[nc]=log10(i);
	  fy3[nc]=whiteCovar[i];
	  nc++;
	}
    }

  cpgbeg(0,"/xs",1,1);
  cpgsch(1.4);
  cpgsfs(2);
  cpgslw(2);
  // Plot the original timing residuals
  minx = TKfindMin_f(fx1,nres);
  maxx = TKfindMax_f(fx1,nres);
  miny = TKfindMin_f(fy1,nres);
  maxy = TKfindMax_f(fy1,nres);
  cpgsvp(0.1,0.95,0.71,0.95);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgsch(1);
  cpgbox("BCTS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("","Residual (s)","");
  cpgsch(1.4);
  cpgpt(nres,fx1,fy1,20);
  cpgerry(nres,fx1,fy1e1,fy1e2,1);

  // Plot the Cholesky whitened timing residuals
  minx = TKfindMin_f(fx2,nres);
  maxx = TKfindMax_f(fx2,nres);
  miny = TKfindMin_f(fy2,nres);
  maxy = TKfindMax_f(fy2,nres);
  cpgsvp(0.1,0.95,0.47,0.71);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgsch(1);
  cpgbox("BCNTS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("Day","White Res. (norm.)","");
  cpgsch(1.4);
  cpgpt(nres,fx2,fy2,20);

  minx = TKfindMin_f(fx3,nc);
  maxx = TKfindMax_f(fx3,nc);
  miny = -2*fabs(zerolagWhiteCovar); //TKfindMin_f(fy3,nc);
  maxy = 2*fabs(zerolagWhiteCovar); //TKfindMax_f(fy3,nc);
  
  cpgsvp(0.1,0.95,0.10,0.35);
  cpgswin(minx,maxx,miny,maxy);
  cpgsch(1);
  cpgbox("BCNLTS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("Lag","Cov.","");
  cpgpt(nc,fx3,fy3,20);
  fx3[0] = minx;
  fy3[0] = zerolagWhiteCovar;
  cpgsch(2);
  cpgsci(2); cpgpt(1,fx3,fy3,18); cpgsci(1); cpgsch(1.4);
  //


  cpgend();
}


void getWhiteRes(double *resx,double *resy,double *rese,int nres,double **uinv,double *cholWhiteY)
{
  int i,j;
  double sum;
  printf("Getting white residuals\n");
  for (i=0;i<nres;i++)
    {
      sum=0.0;
      for (j=0;j<nres;j++)
	{
	  sum+=uinv[j][i]*resy[j];
	  //	  if (i==0) printf("uinv = %g\n",uinv[j+1][i+1]);
	}
      cholWhiteY[i]=sum;
    }
  //  exit(1);
}

void calculateCholesky(double modelAlpha,double modelFc,double modelScale,double fitVar,double **uinv,double *covFunc,
		       double *resx,double *resy,double *rese,int np,double *highFreqRes,double *errorScaleFactor)
{
  int i,j;
  double *f; // Frequency vector
  double *p; // Model of pulsar power spectrum
  double *pe;
  double *pf; // Periodic spectrum model
  double *opf; 
  double weightVarRes,weightMeanRes;
  double weightVarHighFreqRes,weightMeanHighFreqRes;
  double mean,escale,actVar,tt,tl,bl,tl2,bl2;
  int ndays;
  int debug=1;
  double varScaleFactor = 0.6;

  ndays = (int)(ceil(resx[np-1])-floor(resx[0])+1)+2; // Add two extra days for interpolation
  f  = (double *)malloc(sizeof(double)*ndays*2); // Frequency vector
  p  = (double *)malloc(sizeof(double)*ndays); // Model of pulsar power spectrum
  pf = (double *)malloc(sizeof(double)*ndays*2); // Periodic spectrum model
  opf = (double *)malloc(sizeof(double)*ndays*2); // Periodic spectrum model
  pe = (double *)malloc(sizeof(double)*ndays*2); // Periodic spectrum model

  printf("Number of days = %d\n",ndays);

  // Get rms of normalised high freq residuals
  mean=0.0;
  for (i=0;i<np;i++)
    mean+=highFreqRes[i]/rese[i];
  mean/=(double)np;
  escale=0;
  for (i=0;i<np;i++)
    escale += pow(highFreqRes[i]/rese[i]-mean,2);
  escale/=(double)(np-1);
  escale = sqrt(escale);
  printf("Error scaling factor = %g\n",escale);
  // Scale error bars
  // NOTE: Have actually changed the rese[] array
      printf("ERROR NOT SCALING ERRORS\n");
      //printf("WARNING: scaling errors\n");
       escale = 1.0;

  for (i=0;i<np;i++)
    rese[i] *= escale;
  *errorScaleFactor *= escale;
  // Weighted variance of residuals
  weightVarRes=0.0;
  weightMeanRes=0.0;
  tl=0.0; bl=0.0;
  tl2=0.0; bl2=0.0;
  for (i=0;i<np;i++)
    {
      tl+=resy[i]/(rese[i]*rese[i]);
      bl+=1.0/(rese[i]*rese[i]);
      tl2+=highFreqRes[i]/(rese[i]*rese[i]);
    }
  weightMeanRes = tl/bl;
  weightMeanHighFreqRes = tl2/bl;
  tl = bl = tl2 = 0.0;
  for (i=0;i<np;i++)
    {
      tl += pow(resy[i]-weightMeanRes,2)/(rese[i]*rese[i]);
      tl2 += pow(highFreqRes[i]-weightMeanHighFreqRes,2)/(rese[i]*rese[i]);
      bl += 1.0/(rese[i]*rese[i]);
    }
  weightVarRes = tl/bl;
  weightVarHighFreqRes = tl2/bl;

  for (i=0;i<ndays;i++)
    {
      f[i] = i*1.0/(resx[np-1]-resx[0])*365.25;
      p[i] = 1.0/(pow((1.0+pow(f[i]/(modelFc*2),2)),(modelAlpha)/2.0));
      pf[i] = p[i];
    }
  j = ndays;
  for (i=ndays-1;i>0;i--)
    {
      f[j] = -f[i];
      pf[j] = 1.0/(pow((1.0+pow(f[j]/(modelFc*2),2)),modelAlpha/2.0));
      j++;
    }
  if (debug==1)
    {
      FILE *fout;
      fout = fopen("specModel","w");
      for (i=0;i<j;i++)
	fprintf(fout,"%d %g\n",i,pf[i]);
      fclose(fout);     
    }
  printf("Obtaining covariance function from analytic model\n");
  {
    fftw_complex* output;
    fftw_plan transform_plan;
    
    output = (fftw_complex*)opf;
    transform_plan = fftw_plan_dft_r2c_1d(j, pf, output, FFTW_ESTIMATE);
    fftw_execute(transform_plan);    
    fftw_destroy_plan(transform_plan);  
    for (i=0;i<=j/2;i++) 
      {
	covFunc[i] = opf[2*i];
	printf("covFunc: %g %g\n",opf[2*i],opf[2*i+1]);
      }
  }
  // Rescale
  printf("Rescaling %d\n",j/2);
  //  for (i=0;i<np/2;i++)
  //  fy2[i] = nmodelScale-log10(pow((1.0+pow(cholSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0));
  actVar = pow(10,modelScale);
  tt = covFunc[0];
  printf("actvar = %g, weightVarRes = %g, weightVarHighFreqRes = %g, scale = %g, fitVar = %g, tt = %g\n",actVar*pow(86400.0*365.25,2),weightVarRes,weightVarHighFreqRes,weightVarRes-weightVarHighFreqRes,fitVar,tt);

  printf("WARNING: varScaleFactor = %g (used to deal with quadratic removal)\n",varScaleFactor);
  for (i=0;i<=j/2;i++)
    covFunc[i] = covFunc[i]*fitVar*varScaleFactor/tt;

  if (debug==1)
    {
      FILE *fout;
      fout = fopen("scaleCovar","w");
      for (i=0;i<=j/2;i++)
	fprintf(fout,"%d %g\n",i,covFunc[i]);
      fclose(fout);
    }
  // Now get the covariance matrix ...
  // First put the abs(time difference) in each matrix element
  formCholeskyMatrix_pl(covFunc,resx,resy,rese,np,uinv);

  free(p);              
  free(f);
  free(pf);
  free(opf);
  free(pe);
}

void formCholeskyMatrix_pl(double *c,double *resx,double *resy,double *rese,int np,double **uinv)
{
  double **m,**u,sum;
  double *cholp;
  int i,j,k,ix,iy;
  double t0,cint,t;
  int t1,t2;
  int debug=1;

  printf("Getting the covariance matrix\n");
  m = (double **)malloc(sizeof(double *)*(np+1));
  u= (double **)malloc(sizeof(double *)*(np+1));
  cholp  = (double *)malloc(sizeof(double)*(np+1));  // Was ndays

  for (i=0;i<np+1;i++)
    {
      m[i] = (double *)malloc(sizeof(double)*(np+1));
      u[i] = (double *)malloc(sizeof(double)*(np+1));
    }
  
  for (ix=0;ix<np;ix++)
    {
      for (iy=0;iy<np;iy++)
	m[ix][iy] = fabs(resx[ix]-resx[iy]);
    }
  if (debug==1)
    {
      printf("First m = \n");
      for (i=0;i<5;i++)
	{ 
	  for (j=0;j<5;j++) printf("%10g ",m[i][j]); 
	  printf("\n");
	}

    }
  // Insert the covariance which depends only on the time difference.
  // Linearly interpolate between elements on the covariance function because
  // valid covariance matrix must have decreasing off diagonal elements.
  printf("Inserting into the covariance matrix\n");
  for (ix=0;ix<np;ix++)
    {
      for (iy=0;iy<np;iy++)
	{
	  t0 = m[ix][iy];
	  t1 = (int)floor(t0);
	  t2 = t1+1;
	  t  = t0-t1;
	  cint = c[t1]*(1-t)+c[t2]*t; // Linear interpolation
	  m[ix][iy] = cint;
	}
    }
  printf("Multiplying by errors\n");
  for (ix=0;ix<np;ix++)
    m[ix][ix]+=rese[ix]*rese[ix];

  if (debug==1)
    {
      printf("m = \n\n");
      for (i=0;i<5;i++)
	{ 
	  for (j=0;j<5;j++) printf("%10g ",m[i][j]); 
	  printf("\n");
	}
    }

  // Do the Cholesky
  TKcholDecomposition(m,np,cholp);
  // Now calculate uinv
  for (i=0;i<np;i++)
    {
      m[i][i] = 1.0/cholp[i];
      uinv[i][i] = m[i][i];
      for (j=0;j<i;j++)
      	uinv[i][j] = 0.0;
      for (j=i+1;j<np;j++)
	{
	  sum=0.0;
	  for (k=i;k<j;k++) sum-=m[j][k]*m[k][i];
	  m[j][i]=sum/cholp[j];
	  uinv[i][j] = m[j][i];
	}
    } 

  if (debug==1)
    {
      printf("uinv = \n\n");
      for (i=0;i<5;i++)
	{ 
	  for (j=0;j<5;j++) printf("%10g ",uinv[i][j]); 
	  printf("\n");
	}
    }

  printf("Completed inverting the matrix\n");

  // Should free memory not required
  // (note: not freeing uinv)

  for (i=0;i<np+1;i++)
    {
      free(m[i]);
      free(u[i]);
    }
  free(m);
  free(u);
  free(cholp);
}

int fitSpectra(double *preWhiteSpecX,double *preWhiteSpecY,int nPreWhiteSpec,double *modelAlpha,double *modelFc,int *modelNfit,double *modelScale,double *fitVar,int aval,int ipw,double ifc,double iexp,int inpt)
{
  static int time=1;
  double v1,v2,m;
  double df;
  int i;

  if (time==2 && aval==0)
    {
      int redo;
      if (inpt == -1)
	{
	  printf("Redo fit (1 = yes, 0 = no)\n");
	  scanf("%d",&redo);
	  if (redo==0)
	    return 0;
	}
      else
	return 0;
    }
  time=2;
  if (aval==0)
    {
      if (ifc == -1) {printf("Enter corner freq (yr-1) "); scanf("%lf",modelFc);}
      else *modelFc = ifc;
      if (iexp == 0) {printf("Enter power law exponential (should be positive) "); scanf("%lf",modelAlpha);}
      else *modelAlpha = iexp;	
      if (inpt == -1) {printf("Enter nfit "); scanf("%d",modelNfit);}
      else *modelNfit = inpt;
    }
  // Do the fit
  // This fit is useful for fitting spectra where the error is proportional to the mean
  // The error on each point is simply taken as the model value squared and so we solve for
  // chisq = sum (P_d(f) - aM(f))^2/M^2(f)
  // which simplifies to a simple formula
  v1 = 0.0;
  for (i=0;i<*modelNfit;i++)
    {
      m = 1.0/pow((1.0+pow(preWhiteSpecX[i]*365.25/(*modelFc),2)),(*modelAlpha)/2.0);
      v1 += preWhiteSpecY[i]/m;
    }
  //  *modelScale = log10(v1/(double)(*modelNfit));
  *modelScale = (v1/(double)(*modelNfit));
  printf("Model scale = %g\n",*modelScale);

  // Get area under the spectra
  *fitVar=0.0;
  df = preWhiteSpecX[0]*365.25;
  for (i=0;i<*modelNfit;i++)
    *fitVar+=preWhiteSpecY[i]*df;
  (*fitVar)*=pow(86400.0*365.25,2);
  return 1;
}

void plot3(double *preWhiteSpecX,double *preWhiteSpecY,int nPreWhiteSpec,
	   int usePreWhitening,double *highFreqSpecX,double *highFreqSpecY,
	   int nHighFreqSpec,double modelAlpha,double modelFc,int modelNfit,double modelScale,
	   int closeit,float *minx,float *maxx)
{
  int i,j;
  float fx1[nPreWhiteSpec],fy1[nPreWhiteSpec];
  float fx2[nHighFreqSpec],fy2[nHighFreqSpec];
  float fx3[nPreWhiteSpec],fy3[nPreWhiteSpec];
  float fx[2],fy[2];
  float miny,maxy;

  *minx=*maxx=(float)log10(preWhiteSpecX[0]*365.25);
  miny=maxy=(float)log10(preWhiteSpecY[0]);

  for (i=0;i<nPreWhiteSpec;i++)
    {
      fx1[i] = log10(preWhiteSpecX[i]*365.25);
      fy1[i] = log10(preWhiteSpecY[i]);
      if (*minx > fx1[i]) *minx = fx1[i];
      if (*maxx < fx1[i]) *maxx = fx1[i];
      if (miny > fy1[i]) miny = fy1[i];
      if (maxy < fy1[i]) maxy = fy1[i];      
    }

  for (i=0;i<nHighFreqSpec;i++)
    {
      fx2[i] = log10(highFreqSpecX[i]*365.25);
      fy2[i] = log10(highFreqSpecY[i]);
      if (*minx > fx2[i]) *minx = fx2[i];
      if (*maxx < fx2[i]) *maxx = fx2[i];
      if (miny > fy2[i]) miny = fy2[i];
      if (maxy < fy2[i]) maxy = fy2[i];      
    }
  if (closeit==1)
    {
      cpgbeg(0,"/xs",1,1);
      cpgask(0);
      cpgsch(1.4);
      cpgsfs(2);
      cpgslw(2);
      
      cpgenv(*minx-0.1*((*maxx)-(*minx)),(*maxx)+0.1*((*maxx)-(*minx)),
	     miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny),0,10);
      cpglab("Frequency (yr\\u-1\\d)","Power Spectral Density (yr\\u3\\d)","");

    }
  else
    {
      cpgsvp(0.1,0.95,0.45,0.95);
      cpgswin((*minx)-0.1*((*maxx)-(*minx)),(*maxx)+0.1*((*maxx)-(*minx)),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
      cpgbox("BCLTS",0,0,"BCNTS",0,0);
      cpglab("","Power Spectral Density (yr\\u3\\d)","");

    }
  for (i=(int)(miny-0.1*(maxy-miny))-1;i<(int)maxy+1;i++)
    {
      fx[0] = (*minx)-0.1*((*maxx)-(*minx)); fx[1] = (*maxx)+0.1*((*maxx)-(*minx));
      for (j=0;j<10;j++)
	{
	  fy[0] = fy[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }
  for (i=(int)((*minx)-0.1*((*maxx)-(*minx)))-1;i<(int)(*maxx)+1;i++)
    {
      fy[0] = miny-0.1*(maxy-miny); fy[1] = maxy+0.1*(maxy-miny);
      for (j=0;j<10;j++)
	{
	  fx[0] = fx[1] = log10(pow(10,i)*(j+1));
	  cpgsls(4); cpgsci(14); cpgline(2,fx,fy); cpgsci(1); cpgsls(1);
	}
    }
  cpgsci(14);  cpgbox("",0,0,"G",0,0);  cpgsci(1);

  cpgsci(2+usePreWhitening);
  cpgline(nPreWhiteSpec,fx1,fy1);
  cpgpt(nPreWhiteSpec,fx1,fy1,20);

  cpgsci(5);
  cpgline(nHighFreqSpec,fx2,fy2);
  cpgpt(nHighFreqSpec,fx2,fy2,20);
  cpgsci(1);

  // Draw model if required
  if (modelNfit!=-1)
    {
      float fx3[nPreWhiteSpec],fy3[nPreWhiteSpec];
      for (i=0;i<nPreWhiteSpec;i++)
	{
	  fx3[i] = log10(preWhiteSpecX[i]*365.25);
	  //	  fy3[i] = modelScale-log10(pow((1.0+pow(preWhiteSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0));
	  fy3[i] = log10(modelScale*(1.0/pow((1.0+pow(preWhiteSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0)));
	  //	  fy3[i] = log10(pow(10,modelScale)/365.25)-log10(pow((1.0+pow(preWhiteSpecX[i]*365.25/modelFc,2)),modelAlpha/2.0));
	}
      cpgsls(3); cpgsci(1); cpgline(nPreWhiteSpec,fx3,fy3); cpgsci(1); cpgsls(1);
    }
  if (closeit==1) cpgend();
}

// Exponential smoothing and interpolation
void interpolate(double *resx,double *resy,double *rese,
		 int nres,double *cubicVal,double *interpX,
		 double *interpY,int *nInterp,int interpTime,double expSmooth)
{
  int i,j;
  double tl,bl,dt;
  double yval;
  
  *nInterp = (int)((resx[nres-1]-resx[0])/interpTime+0.5); // Number of interpolated points
  for (i=0;i<*nInterp;i++)
    {
      interpX[i] = resx[0]+i*interpTime;
      tl = 0.0;
      bl = 0.0;
      // Interpolate difference between points and cubic
      for (j=0;j<nres;j++)
	{
	  dt = interpX[i] - resx[j];
	  yval = resy[j]-(cubicVal[0] + cubicVal[1]*resx[j] + 
		  cubicVal[2]*pow(resx[j],2) + cubicVal[3]*pow(resx[j],3));


	  tl += yval/rese[j]/rese[j]*exp(-fabs(dt/expSmooth));
	  bl += 1.0/rese[j]/rese[j]*exp(-fabs(dt/expSmooth));
	}	    
      interpY[i] = tl/bl;      
      // Add on cubic
      interpY[i] += (cubicVal[0] + cubicVal[1]*interpX[i] + 
		     cubicVal[2]*pow(interpX[i],2) + cubicVal[3]*pow(interpX[i],3));
    }
  if(writeFiles)
  {
    FILE *fout;
    fout = fopen("interp.dat","w");
    for (i=0;i<*nInterp;i++)
      fprintf(fout,"%g %g\n",interpX[i],interpY[i]);
    fclose(fout);
  }
}

void plot2(double *origSpecX,double *origSpecY,int nOrigSpec,double *smoothSpecX0,
	   double *smoothSpecY0,int nSmoothSpec0,double *smoothSpecX1,
	   double *smoothSpecY1,int nSmoothSpec1,double *smoothSpecX2,
	   double *smoothSpecY2,int nSmoothSpec2,double *highFreqSpecX,
	   double *highFreqSpecY,int nHighFreqSpec,int makeps)
{
  float fx[2],fy[2];
  float fx1[nOrigSpec],fy1[nOrigSpec];
  float fx2[nSmoothSpec0],fy2[nSmoothSpec0];
  float fx3[nSmoothSpec1],fy3[nSmoothSpec1];
  float fx4[nSmoothSpec2],fy4[nSmoothSpec2];
  float fx5[nHighFreqSpec],fy5[nHighFreqSpec];
  float minx,maxx,miny,maxy;
  int i;

  for (i=0;i<nOrigSpec;i++)
    {
      fx1[i] = log10(origSpecX[i]*365.25);
      fy1[i] = log10(origSpecY[i]);
      if (i==0)
	{
	  minx = maxx = fx1[i];
	  miny = maxy = fy1[i];
	}
      else
	{
	  if (minx > fx1[i]) minx = fx1[i];
	  if (maxx < fx1[i]) maxx = fx1[i];
	  if (miny > fy1[i]) miny = fy1[i];
	  if (maxy < fy1[i]) maxy = fy1[i];
	}

    }
  // Smooth spec
  for (i=0;i<nSmoothSpec0;i++)
    {
      fx2[i] = log10(smoothSpecX0[i]*365.25);
      fy2[i] = log10(smoothSpecY0[i]);
      if (minx > fx2[i]) minx = fx2[i];
      if (maxx < fx2[i]) maxx = fx2[i];
      if (miny > fy2[i]) miny = fy2[i];
      if (maxy < fy2[i]) maxy = fy2[i];

    }

  // Smooth spec prewhite 1
  for (i=0;i<nSmoothSpec1;i++)
    {
      fx3[i] = log10(smoothSpecX1[i]*365.25);
      fy3[i] = log10(smoothSpecY1[i]);
      if (minx > fx3[i]) minx = fx3[i];
      if (maxx < fx3[i]) maxx = fx3[i];
      if (miny > fy3[i]) miny = fy3[i];
      if (maxy < fy3[i]) maxy = fy3[i];
    }
  // Smooth spec prewhite 2
  for (i=0;i<nSmoothSpec2;i++)
    {
      fx4[i] = log10(smoothSpecX2[i]*365.25);
      fy4[i] = log10(smoothSpecY2[i]);
      if (minx > fx4[i]) minx = fx4[i];
      if (maxx < fx4[i]) maxx = fx4[i];
      if (miny > fy4[i]) miny = fy4[i];
      if (maxy < fy4[i]) maxy = fy4[i];
    }
  // High frequency residuals
  for (i=0;i<nHighFreqSpec;i++)
    {
      fx5[i] = log10(highFreqSpecX[i]*365.25);
      fy5[i] = log10(highFreqSpecY[i]);
      if (minx > fx5[i]) minx = fx5[i];
      if (maxx < fx5[i]) maxx = fx5[i];
      if (miny > fy5[i]) miny = fy5[i];
      if (maxy < fy5[i]) maxy = fy5[i];
    }

  if (makeps==1) // For paper
    {
      float sx[MAX_OBSN],sy[MAX_OBSN];
      cpgbeg(0,"spectralPlot2.ps/ps",1,1);
      cpgsch(2.0);
      cpgpap(0,0.400);
      cpgsch(2.0); cpgsfs(2); cpgslw(2);
      //      cpgenv(minx,1,miny+1,maxy,0,10);
      cpgenv(-1.2,1,miny+1,maxy,0,10);
      cpglab("Frequency (yr\\u-1\\d)","log\\d10\\u[Power Spectral Density (yr\\u3\\d)]","");
      cpgtext(-1.1,-19,"(b)");
      //      cpgline(nOrigSpec,fx1,fy1);
      //      cpgsls(2);  cpgline(nHighFreqSpec,fx2,fy2);  cpgpt(nHighFreqSpec,fx2,fy2,20);  cpgsls(1);
      //      cpgsls(2);  cpgline(nHighFreqSpec,fx2,fy2);  cpgsls(1);
      cpgsls(1);  cpgline(nHighFreqSpec,fx3,fy3);    cpgsls(1);
      //      cpgsci(7);  cpgline(nHighFreqSpec,fx5,fy5); cpgpt(nHighFreqSpec,fx5,fy5,16);cpgsci(1);
      cpgsls(4);  cpgline(nHighFreqSpec,fx5,fy5); cpgsci(1);
      sx[0] = sx[1] = 0;
      sy[0] = miny; sy[1] = maxy;
      cpgsls(4); cpgline(2,sx,sy); cpgsls(1);
      // Overlay model
      for (i=0;i<nHighFreqSpec;i++)
	{
	  sx[i] = fx2[i];
	  	  sy[i] = log10(3.27306e-18*(1.0/pow((1.0+pow(smoothSpecX1[i]*365.25/0.2,2)),5.0/2.0)));
		  // sy[i] = log10(7.88532e-23*(1.0/pow((1.0+pow(smoothSpecX1[i]*365.25/0.04,2)),5.0/2.0)));
	}
      cpgslw(3); cpgline(nHighFreqSpec,sx,sy); cpgslw(2);
      cpgend();
    }


  cpgbeg(0,"/xs",1,1);
  cpgask(0);
  cpgsch(1.4);
  cpgsfs(2);
  cpgslw(2);
  cpgenv(minx,maxx,miny,maxy,0,10);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("Frequency (yr\\u-1\\d)","Power Spectral Density (yr\\u3\\d)","");
  cpgline(nOrigSpec,fx1,fy1);
  cpgpt(nOrigSpec,fx1,fy1,20);
  cpgsci(2);  cpgline(nSmoothSpec0,fx2,fy2);  cpgpt(nSmoothSpec0,fx2,fy2,20);  cpgsci(1);
  cpgsci(3);  cpgline(nSmoothSpec1,fx3,fy3);  cpgpt(nSmoothSpec1,fx3,fy3,20);  cpgsci(1);
  cpgsci(4);  cpgline(nSmoothSpec2,fx4,fy4);  cpgpt(nSmoothSpec2,fx4,fy4,20);  cpgsci(1);
  cpgsci(5);  cpgline(nHighFreqSpec,fx5,fy5); cpgpt(nHighFreqSpec,fx5,fy5,20);  cpgsci(1);

  // Overplot slopes of -2,-4,-6
  fx[0] = minx;
  fy[0] = maxy;
  fx[1] = maxx;
  fy[1] = maxy + (maxx-minx)*(-2);
  cpgsls(4); cpgline(2,fx,fy); cpgsls(1);
  fy[1] = maxy + (maxx-minx)*(-4);
  cpgsci(7); cpgsls(4); cpgline(2,fx,fy); cpgsls(1); cpgsci(1);
  fy[1] = maxy + (maxx-minx)*(-6);
  cpgsci(8); cpgsls(4); cpgline(2,fx,fy); cpgsls(1); cpgsci(1);


}

int calculateSpectra(double *x,double *y,double *e,int n,int useErr,int preWhite,
		     int specType,double *specX,double *specY)
{
  int nSpec;
  int i;
  int passSpecType;
  double outY_im[n],outY_re[n];

  if (specType==1) // Weighted Lomb Scargle
    passSpecType=4;
  else if (specType==2)
    passSpecType=2;

  TKspectrum(x,y,e,n,0,0,0,0,preWhite,passSpecType,1,1,1,specX,specY,&nSpec,0,0,outY_re,outY_im);
  
  return nSpec;
}
void getHighFreqCovar(double *resx,double *rese,double *highFreqRes,int nres,double *hfNormCovar,int *hfNormCovarNpts,double *hfZerolagNormCovar)
{
  int i,j;
  double yv[nres];
  double mean;

  // Should remove normal mean or weighted mean??
  mean = TKmean_d(highFreqRes,nres);
  for (i=0;i<nres;i++)
    yv[i] = (highFreqRes[i]-mean)/rese[i];

  calculateDailyCovariance(resx,yv,rese,nres,hfNormCovar,hfNormCovarNpts,hfZerolagNormCovar,0);

}

void calculateDailyCovariance(double *x,double *y,double *e,int n,double *cv,int *in,double *zl,int usewt)
{
  int i,j;
  int nd = (int)(x[n-1]-x[0]+0.5);
  int nc=0;
  int nzl=0;
  int npts[nd];
  double dt;
  double wt[nd];
  double nzerolag=0.0;

  for (i=0;i<nd;i++)
    {
      cv[i] = 0.0;
      in[i] = 0;
      wt[i] = 0.0;
    }
  *zl = 0.0;
 
 // Bin in 1 day intervals
  for (i=0;i<n;i++)
    {
      for (j=i;j<n;j++)
	{
	  dt = fabs(x[i]-x[j]);
	  if (dt == 0) // Absolute zero time delay
	    {
	      (*zl)+=(y[i]*y[j]);
	      nzl++;
	    }
	  else 
	    {
	      if (usewt==0)
		cv[(int)(dt+0.5)]+=(y[i]*y[j]);
	      else
		cv[(int)(dt+0.5)]+=(y[i]*y[j])/(e[i]*e[j]);
	      in[(int)(dt+0.5)]++;
	      wt[(int)(dt+0.5)]+=1.0/(e[i]*e[j]);
	    }
	}
    }
  printf("zl = %g\n",*zl);
  (*zl)/=(double)nzl;
  for (i=0;i<nd;i++)
    {
      if (in[i] > 0)
	{
	  if (usewt==0)
	    cv[i]/=(double)in[i];
	  else
	    cv[i]/=(double)wt[i];
	}
    }

}

void getHighFreqRes(double *resy,double *smoothModel,int nres,double *highFreqRes)
{
  int i;
  for (i=0;i<nres;i++)
    highFreqRes[i] = resy[i] - smoothModel[i];
}

// Note: do a weighted exponential smoothing.  Bill originally used an unweighted smoother
void findSmoothCurve(double *resx,double *resy,double *rese,
		     int nres,double *cubicVal,double *smoothModel,double expSmooth)
{
  int i,j;
  double tl,bl;
  double diffy[nres];
  double dt;

  // Obtain difference between residuals and the cubic fit
  for (i=0;i<nres;i++)
    {
      diffy[i] = resy[i] - (cubicVal[0] + cubicVal[1]*resx[i] + 
			    cubicVal[2]*pow(resx[i],2) + cubicVal[3]*pow(resx[i],3));
    }
  // Smooth to get model of the timing residuals
  for (i=0;i<nres;i++)
    {
      tl = 0.0;
      bl = 0.0;
      for (j=0;j<nres;j++)
	{
	  dt = resx[i] - resx[j];
	  tl += diffy[j]*exp(-fabs(dt/expSmooth))/rese[j]/rese[j];
	  bl += 1.0*exp(-fabs(dt/expSmooth))/rese[j]/rese[j];
	  //	  tl += diffy[j]*exp(-fabs(dt/expSmooth));
	  //	  bl += 1.0*exp(-fabs(dt/expSmooth));
	}
      smoothModel[i] = tl/bl + (cubicVal[0] + cubicVal[1]*resx[i] + 
				cubicVal[2]*pow(resx[i],2) + 
				cubicVal[3]*pow(resx[i],3));
    }
}

void plot1(double *resx,double *resy,double *rese,int nres,double *cubicVal,double *smoothModel,double *highFreqRes,double *hfNormCovar,int *hfNormCovarNpts,double hfZerolagNormCovar)
{
  int dspan=(int)(resx[nres-1]-resx[0]+0.5);
  float fx[nres],fy[nres],fe1[nres],fe2[nres];
  float fx2[dspan],fy2[dspan];
  float fy3[nres],fy4[nres];
  float fx5[dspan],fy5[dspan];
  float minx,maxx,miny,maxy;
  int i,j,ncovar,np;

  cpgbeg(0,"/xs",1,1); cpgsch(1.4); cpgsfs(2); cpgslw(2);
  // Plot timing residuals
  for (i=0;i<nres;i++)
    {
      fx[i] = (float)resx[i];
      fy[i] = (float)resy[i];
      fe1[i] = (float)(resy[i]-rese[i]);
      fe2[i] = (float)(resy[i]+rese[i]);
    }
  minx = TKfindMin_f(fx,nres);  maxx = TKfindMax_f(fx,nres);
  miny = TKfindMin_f(fy,nres);  maxy = TKfindMax_f(fy,nres);
  cpgsvp(0.1,0.95,0.71,0.95);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgsch(1);
  cpgbox("BCTS",0,0,"BCNTS",0,0); cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("","Residual (s)","");
  cpgsch(1.4);
  cpgpt(nres,fx,fy,1);
  cpgerry(nres,fx,fe1,fe2,1);
  
  // Overplot the cubic fit
  for (i=0;i<dspan;i++)
    {
      fx2[i] = resx[0]+i;
      fy2[i] = cubicVal[0] + cubicVal[1]*fx2[i] + cubicVal[2]*pow(fx2[i],2) + 
	cubicVal[3]*pow(fx2[i],3);
    }
  cpgsci(2); cpgline(dspan,fx2,fy2); cpgsci(1);

  // Overplot the smoothed model of the residuals
  for (i=0;i<nres;i++) fy3[i] = (float)smoothModel[i];
  cpgsci(3); cpgsls(2); cpgline(nres,fx,fy3); cpgsls(1); cpgsci(1);

  // Plot the high frequency residuals
  for (i=0;i<nres;i++) fy4[i] = (float)highFreqRes[i];
  miny = TKfindMin_f(fy4,nres);
  maxy = TKfindMax_f(fy4,nres);

  cpgsvp(0.1,0.95,0.47,0.71);
  cpgswin(minx-0.1*(maxx-minx),maxx+0.1*(maxx-minx),miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  cpgsch(1);
  cpgbox("BNCTS",0,0,"BCNTS",0,0);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpglab("Day","HF Residual (s)","");
  cpgpt(nres,fx,fy4,20);
  
  // Plot the normalised covariances
  ncovar=0;
  for (i=1;i<dspan;i++)
    {
      if (hfNormCovarNpts[i] > 0)
	{
	  fx5[ncovar] = log10(i);
	  fy5[ncovar] = hfNormCovar[i];
	  ncovar++;
	}
    }
  minx = TKfindMin_f(fx5,ncovar);
  maxx = TKfindMax_f(fx5,ncovar);
  miny = -2.0*fabs(hfZerolagNormCovar); //TKfindMin_f(fy5,ncovar);
  maxy = 2.0*fabs(hfZerolagNormCovar); //TKfindMax_f(fy5,ncovar);
  cpgsvp(0.1,0.95,0.10,0.35);
  cpgswin(minx,maxx,miny-0.1*(maxy-miny),maxy+0.1*(maxy-miny));
  
  cpglab("Lag (d)","Norm. Covariance","");
  //    cpgenv(minx,maxx,miny,maxy,0,10);
  cpgsci(14);  cpgbox("G",0,0,"G",0,0);  cpgsci(1);
  cpgbox("BNCTLS",0,0,"BCNTS",0,0);
  cpgpt(ncovar,fx5,fy5,20);
  fx5[0] = 0;fy5[0] = (float)hfZerolagNormCovar;
  cpgsch(2); cpgsci(2); cpgpt(1,fx5,fy5,18); cpgsci(1); cpgsch(1.4);

  // Now overplot the normalised covariance binned in 10 day intervals
  ncovar=0;
    for (i=1;i<dspan;i+=10)
    {
      np = 0;
      fx5[ncovar] = 0.0;
      fy5[ncovar] = 0.0;

      for (j=i;j<i+10;j++)
	{
	  if (hfNormCovarNpts[j] > 0)
	    {
	      fx5[ncovar] += j*hfNormCovarNpts[j];
	      fy5[ncovar] += (hfNormCovar[j]*hfNormCovarNpts[j]);
	      np+=hfNormCovarNpts[j];
	    }
	}
      if (np>0)
	{
	  fx5[ncovar]=log10(fx5[ncovar]/(double)np);
	  fy5[ncovar]/=(double)np;
	  ncovar++;
	}
    }
  cpgsci(3); cpgpt(ncovar,fx5,fy5,7);   cpgsci(1);

  // Now overplot the normalised covariance binned in 100 day intervals
  ncovar=0;
    for (i=1;i<dspan;i+=100)
    {
      np = 0;
      fx5[ncovar] = 0.0;
      fy5[ncovar] = 0.0;

      for (j=i;j<i+100;j++)
	{
	  if (hfNormCovarNpts[j] > 0)
	    {
	      fx5[ncovar] += j*hfNormCovarNpts[j];
	      fy5[ncovar] += (hfNormCovar[j]*hfNormCovarNpts[j]);
	      np+=hfNormCovarNpts[j];
	    }
	}
      if (np>0)
	{
	  fx5[ncovar]=log10(fx5[ncovar]/(double)np);
	  fy5[ncovar]/=(double)np;
	  ncovar++;
	}
    }
  cpgsci(4); cpgpt(ncovar,fx5,fy5,16);   cpgsci(1);
  
  cpgend();
}


// NOTE: Bill does an unweighted fit
//
void cubicFit(double *resx,double *resy,double *rese,int nres,double *cubicVal,double *cubicErr)
{
  double **cvm;
  int i;
  int nfit=4; // a+b*x+c*x^2 + d*x^3 
  double chisq;
  int useWeight=0;

  // Allocate memory for fit covariance matrix
  cvm = (double **)malloc(sizeof(double *)*nfit);
  for (i=0;i<nfit;i++) cvm[i] = (double *)malloc(sizeof(double)*nfit);

  TKleastSquares_svd(resx,resy,rese,nres,cubicVal,cubicErr,nfit,cvm,&chisq,TKfitPoly,useWeight);

  // Provide information about the fit
  printf("---------------------------------------------------------\n");
  printf("Cubic fit to timing residuals:\n");
  printf("y = %.5g + %.5g * x + %.5g * x^2 + %.5g * x^3\n",cubicVal[0],cubicVal[1],
	 cubicVal[2],cubicVal[3]);
  printf("chisq of fit = %g, reduced chisq = %g\n",chisq,chisq/(nres-4.0));
  printf("\n");
  printf("This curve is plotted as a red line through the timing residuals\n");
  printf("---------------------------------------------------------\n");
  

  // Free memory allocation
  for (i=0;i<nfit;i++) free(cvm[i]);
  free(cvm);
  
}

// Fill resx with the SATs (in days), resy with post-fit residuals (s) and rese
// with TOA errors (s)
//
int obtainTimingResiduals(pulsar *psr,double *resx,double *resy,double *rese)
{
  int i;
  int nres=0;

  for (i=0;i<psr[0].nobs;i++)
    {
      if (psr[0].obsn[i].deleted==0)
	{
	  resx[nres] = (double)(psr[0].obsn[i].sat - psr[0].param[param_pepoch].val[0]);
	  // Check to make sure that the data are time sorted
	  if (nres>0 && resx[nres] < resx[nres-1])
	    {
	      printf("ERROR: Data are not time sorted\n");
	      exit(1);
	    }
	  resy[nres] = (double)(psr[0].obsn[i].residual);
	  rese[nres] = (double)(psr[0].obsn[i].toaErr*1.0e-6);
	  nres++;
	}
    }

  
  

  return nres;
}




char * plugVersionCheck = TEMPO2_h_VER;
